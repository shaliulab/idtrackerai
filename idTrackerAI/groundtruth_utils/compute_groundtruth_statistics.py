from __future__ import absolute_import, print_function, division
import os
import sys
sys.path.append('../')
sys.path.append('../preprocessing')
sys.path.append('../utils')
import numpy as np
import logging
from pprint import pprint

from GUI_utils import selectDir
from list_of_blobs import ListOfBlobs
from blob import Blob
from generate_groundtruth import GroundTruth, GroundTruthBlob

"""Given two list of blobs_in_video, one deduced from human groundtruth and the other
generated by the tracking algorithm, compares them and gives back some statistics

Crossing: crossings are a special case. We ...
"""
logger = logging.getLogger("__main__.compute_statistics_against_groundtruth")

def compare_tracking_against_groundtruth(number_of_animals, blobs_in_video_groundtruth, blobs_in_video, identities_dictionary_permutation):
    #create dictionary to store eventual corrections made by the user
    results = {}
    results['number_of_blobs_per_identity'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_assigned_blobs_per_identity'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_blobs_assigned_during_accumulation_per_identity'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_blobs_after_accumulation_per_identity'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_errors_in_all_blobs'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_errors_in_assigned_blobs'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_errors_in_blobs_assigned_during_accumulation'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_errors_in_blobs_after_accumulation'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_errors_in_blobs_assigned_after_accumulation'] = {i:0 for i in range(1, number_of_animals + 1)}
    results['number_of_crossing_blobs'] = 0
    results['number_of_crossings_blobs_assigned_as_individuals'] = 0
    results['frames_with_identity_errors'] = []
    results['fragment_identifiers_with_identity_errors'] = []
    results['frames_with_crossing_errors'] = []
    results['fragment_identifiers_with_crossing_errors'] = []
    results['frames_with_zeros_in_groundtruth'] = []

    for groundtruth_blobs_in_frame, blobs_in_frame in zip(blobs_in_video_groundtruth, blobs_in_video):

        for groundtruth_blob, blob in zip(groundtruth_blobs_in_frame,blobs_in_frame):

            if identities_dictionary_permutation is not None:
                gt_identity = identities_dictionary_permutation[groundtruth_blob.identity]
            else:
                gt_identity = groundtruth_blob.identity

            if groundtruth_blob.is_an_individual and gt_identity != -1: # we are not considering crossing or failures of the model area
                if gt_identity == 0:
                    results['frames_with_zeros_in_groundtruth'].append(groundtruth_blob.frame_number)

                else:
                    results['number_of_blobs_per_identity'][gt_identity] += 1
                    results['number_of_assigned_blobs_per_identity'][gt_identity] += 1 if blob.assigned_identity != 0 else 0
                    results['number_of_blobs_assigned_during_accumulation_per_identity'][gt_identity] += 1 if blob.used_for_training else 0
                    results['number_of_blobs_after_accumulation_per_identity'][gt_identity] += 1 if not blob.used_for_training else 0
                    if gt_identity != blob.assigned_identity:
                        results['number_of_errors_in_all_blobs'][gt_identity] += 1
                        results['number_of_errors_in_blobs_after_accumulation'][gt_identity] += 1 if not blob.used_for_training else 0
                        if blob.assigned_identity != 0:
                            results['number_of_errors_in_assigned_blobs'][gt_identity] += 1
                            results['number_of_errors_in_blobs_assigned_during_accumulation'][gt_identity] += 1 if blob.used_for_training else 0
                            results['number_of_errors_in_blobs_assigned_after_accumulation'][gt_identity] += 1 if not blob.used_for_training else 0
                        if blob.fragment_identifier not in results['fragment_identifiers_with_identity_errors']:
                            results['frames_with_identity_errors'].append(blob.frame_number)
                            results['fragment_identifiers_with_identity_errors'].append(blob.fragment_identifier)

            elif groundtruth_blob.is_a_crossing or gt_identity == -1:
                results['number_of_crossing_blobs'] += 1
                results['number_of_crossings_blobs_assigned_as_individuals'] += 1 if blob.is_an_individual else 0
                if blob.is_an_individual:
                    if blob.fragment_identifier not in results['fragment_identifiers_with_crossing_errors']:
                        results['frames_with_crossing_errors'].append(blob.frame_number)
                        results['fragment_identifiers_with_crossing_errors'].append(blob.fragment_identifier)

    return results

def check_ground_truth_consistency(blobs_in_video_groundtruth, blobs_in_video, first_frame_first_global_fragment):

    if first_frame_first_global_fragment is not None \
        and first_frame_first_global_fragment > len(blobs_in_video_groundtruth):
        raise ValueError('The first_frame_first_global_fragment is bigger than the length of the groundtruth video')

    if len(blobs_in_video_groundtruth) != len(blobs_in_video):
        raise ValueError('Cannot compute the accuracy from a list of blobs with different length than the blobs_in_video_groundtruth')

    for blobs_in_frame_gt, blobs_in_frame in zip(blobs_in_video_groundtruth, blobs_in_video):

        if len(blobs_in_frame) != len(blobs_in_frame_gt):
            raise ValueError('Cannot compute the accuracy form a list of blobs with different blobs per frame than the blobs_in_video_groundtruth')


def get_accuracy_wrt_groundtruth(video, blobs_in_video_groundtruth, blobs_in_video = None, first_frame_first_global_fragment = None):

    check_ground_truth_consistency(blobs_in_video_groundtruth, blobs_in_video, first_frame_first_global_fragment)

    if first_frame_first_global_fragment is not None:
        groundtruth_identities_in_first_frame = [blob.identity for blob in blobs_in_video_groundtruth[first_frame_first_global_fragment]]
        identities_in_first_frame = [blob.identity for blob in blobs_in_video[first_frame_first_global_fragment]]
        print(groundtruth_identities_in_first_frame, identities_in_first_frame)

        identities_dictionary_permutation = {groundtruth_identity: identity
                                                for identity, groundtruth_identity in zip(identities_in_first_frame, groundtruth_identities_in_first_frame)}
    else:
        identities_dictionary_permutation = None

    number_of_animals = video.number_of_animals
    if blobs_in_video is None:
        blobs_in_video = blobs_in_video_groundtruth
    results = compare_tracking_against_groundtruth(number_of_animals, blobs_in_video_groundtruth, blobs_in_video, identities_dictionary_permutation)

    if len(results['frames_with_zeros_in_groundtruth']) == 0:
        # pprint(results)
        accuracies = {}

        accuracies['individual_accuracy'] = {i : 1 - results['number_of_errors_in_all_blobs'][i] / results['number_of_blobs_per_identity'][i]
                                for i in range(1, number_of_animals + 1)}
        accuracies['accuracy'] = np.mean(accuracies['individual_accuracy'].values())
        accuracies['individual_accuracy_assigned'] = {i : 1 - results['number_of_errors_in_assigned_blobs'][i] / results['number_of_assigned_blobs_per_identity'][i]
                                        for i in range(1, number_of_animals + 1)}
        accuracies['accuracy_assigned'] = np.mean(accuracies['individual_accuracy_assigned'].values())
        accuracies['individual_accuracy_in_accumulation'] = {i : 1 - results['number_of_errors_in_blobs_assigned_during_accumulation'][i] / results['number_of_blobs_assigned_during_accumulation_per_identity'][i]
                                for i in range(1, number_of_animals + 1)}
        accuracies['accuracy_in_accumulation'] = np.mean(accuracies['individual_accuracy_in_accumulation'].values())

        accuracies['individual_accuracy_after_accumulation'] = {}
        for i in range(1, number_of_animals + 1):
            if results['number_of_blobs_after_accumulation_per_identity'][i] != 0:
                accuracies['individual_accuracy_after_accumulation'][i] = 1 - results['number_of_errors_in_blobs_after_accumulation'][i] / results['number_of_blobs_after_accumulation_per_identity'][i]
            else:
                accuracies['individual_accuracy_after_accumulation'][i] = np.nan

        accuracies['accuracy_after_accumulation'] = np.nanmean(accuracies['individual_accuracy_after_accumulation'].values())

        if results['number_of_crossing_blobs'] != 0:
            accuracies['crossing_detector_accuracy'] = 1. - results['number_of_crossings_blobs_assigned_as_individuals'] / results['number_of_crossing_blobs']
        else:
            accuracies['crossing_detector_accuracy'] = None

        pprint(accuracies)

        return accuracies, results['frames_with_zeros_in_groundtruth']

    else:
        print("there are fish with 0 identity in frame ", results['frames_with_zeros_in_groundtruth'])
        return None, results['frames_with_zeros_in_groundtruth']

def compute_and_save_session_accuracy_wrt_groundtruth(video, video_object_path):
    video.check_paths_consistency_with_video_path(video_object_path)
    # change this
    print("loading list_of_blobs")
    list_of_blobs = ListOfBlobs.load(video, video.blobs_path)

    ''' select ground truth file '''
    print("loading groundtruth")
    groundtruth_path = os.path.join(video.video_folder,'_groundtruth.npy')
    groundtruth = np.load(groundtruth_path).item()
    blobs_in_video_groundtruth = groundtruth.blobs_in_video[groundtruth.start:groundtruth.end]
    blobs_in_video = list_of_blobs.blobs_in_video[groundtruth.start:groundtruth.end]

    print("computing groundtruth")
    accuracies, frames_with_zeros_in_groundtruth = get_accuracy_wrt_groundtruth(video, blobs_in_video_groundtruth, blobs_in_video)

    if accuracies is not None:
        print("saving accuracies in video")
        video.gt_start_end = (groundtruth.start,groundtruth.end)
        video.gt_accuracies = accuracies
        video.save()

if __name__ == '__main__':

    ''' select blobs_in_video list tracked to compare against ground truth '''
    session_path = selectDir('./') #select path to video
    video_object_path = os.path.join(session_path,'video_object.npy')
    print("loading video object...")
    video = np.load(video_object_path).item(0)

    compute_and_save_session_accuracy_wrt_groundtruth(video, video_object_path)
