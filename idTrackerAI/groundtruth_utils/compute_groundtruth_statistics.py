from __future__ import absolute_import, print_function, division
import os
import sys
sys.path.append('../')
sys.path.append('../preprocessing')
sys.path.append('../utils')
import numpy as np
import logging

from GUI_utils import selectDir
from list_of_blobs import ListOfBlobs
from blob import Blob
from generate_groundtruth import GroundTruth, GroundTruthBlob

"""Given two list of blobs_in_video, one deduced from human groundtruth and the other
generated by the tracking algorithm, compares them and gives back some statistics

Crossing: crossings are a special case. We ...
"""
logger = logging.getLogger("__main__.compute_statistics_against_groundtruth")

def compare_tracking_against_groundtruth(number_of_animals, blobs_in_video_groundtruth, blobs_in_video):
    #create dictionary to store eventual corrections made by the user
    number_of_assigned_blobs_to_identity = {i:0 for i in range(1, number_of_animals + 1)}
    number_of_blobs_of_identity = {i:0 for i in range(1, number_of_animals + 1)}
    number_of_errors_in_assigned_blobs = {i:0 for i in range(1, number_of_animals + 1)}
    number_of_errors_in_all_blobs = {i:0 for i in range(1, number_of_animals + 1)}
    number_of_crossing_blobs = 0
    number_of_crossings_blobs_assigned_as_individuals = 0
    frames_with_identity_errors = []
    fragment_identifiers_with_identity_errors = []
    frames_with_crossing_errors = []
    fragment_identifiers_with_crossing_errors = []
    frames_with_zeros_in_groundtruth = []

    for groundtruth_blobs_in_frame, blobs_in_frame in zip(blobs_in_video_groundtruth, blobs_in_video):

        for groundtruth_blob, blob in zip(groundtruth_blobs_in_frame,blobs_in_frame):

            if groundtruth_blob.is_an_individual and groundtruth_blob.identity != -1: # we are not considering crossing or failures of the model area
                if groundtruth_blob.identity == 0:
                    frames_with_zeros_in_groundtruth.append(groundtruth_blob.frame_number)

                number_of_blobs_of_identity[groundtruth_blob.identity] += 1
                number_of_assigned_blobs_to_identity[groundtruth_blob.identity] += 1 if blob.assigned_identity != 0 else 0
                if groundtruth_blob.identity != blob.assigned_identity:
                    number_of_errors_in_all_blobs[groundtruth_blob.identity] += 1
                    if blob.assigned_identity != 0:
                        number_of_errors_in_assigned_blobs[groundtruth_blob.identity] += 1
                    if blob.fragment_identifier not in fragment_identifiers_with_identity_errors:
                        frames_with_identity_errors.append(blob.frame_number)
                        fragment_identifiers_with_identity_errors.append(blob.fragment_identifier)

            elif groundtruth_blob.is_a_crossing or groundtruth_blob.identity == -1:
                number_of_crossing_blobs += 1
                number_of_crossings_blobs_assigned_as_individuals += 1 if blob.is_an_individual else 0
                if blob.is_an_individual:
                    if blob.fragment_identifier not in fragment_identifiers_with_crossing_errors:
                        frames_with_crossing_errors.append(blob.frame_number)
                        fragment_identifiers_with_crossing_errors.append(blob.fragment_identifier)

    return number_of_assigned_blobs_to_identity, \
            number_of_blobs_of_identity, \
            number_of_errors_in_assigned_blobs, \
            number_of_errors_in_all_blobs, \
            number_of_crossing_blobs, \
            number_of_crossings_blobs_assigned_as_individuals, \
            frames_with_identity_errors, \
            fragment_identifiers_with_identity_errors, \
            frames_with_crossing_errors, \
            fragment_identifiers_with_crossing_errors, \
            frames_with_zeros_in_groundtruth


def get_accuracy_wrt_groundtruth(video, blobs_in_video_groundtruth, blobs_in_video = None):
    number_of_animals = video.number_of_animals
    if blobs_in_video is None:
        blobs_in_video = blobs_in_video_groundtruth
    number_of_assigned_blobs_to_identity, \
    number_of_blobs_of_identity, \
    number_of_errors_in_assigned_blobs, \
    number_of_errors_in_all_blobs, \
    number_of_crossing_blobs, \
    number_of_crossings_blobs_assigned_as_individuals, \
    frames_with_identity_errors, \
    fragment_identifiers_with_identity_errors, \
    frames_with_crossing_errors, \
    fragment_identifiers_with_crossing_errors, \
    frames_with_zeros_in_groundtruth = compare_tracking_against_groundtruth(number_of_animals,
                                                                            blobs_in_video_groundtruth,
                                                                            blobs_in_video)

    if len(frames_with_zeros_in_groundtruth) == 0:

        individual_accuracy_assigned = {i : 1 - number_of_errors_in_assigned_blobs[i] / number_of_assigned_blobs_to_identity[i] for i in range(1, number_of_animals + 1)}
        accuracy_assigned = np.mean(individual_accuracy_assigned.values())
        individual_accuracy = {i : 1 - number_of_errors_in_all_blobs[i] / number_of_blobs_of_identity[i] for i in range(1, number_of_animals + 1)}
        accuracy = np.mean(individual_accuracy.values())
        if number_of_crossing_blobs != 0:
            crossing_detector_accuracy = 1. - number_of_crossings_blobs_assigned_as_individuals / number_of_crossing_blobs
        else:
            crossing_detector_accuracy = None

        print("\n")
        print("number_of_blobs_of_identity: ", number_of_blobs_of_identity)
        print("number_of_errors_in_all_blobs: ", number_of_errors_in_all_blobs)
        print("individual_accuracy: ", individual_accuracy)
        print("accuracy: ", accuracy)
        print("\n")
        print("number_of_assigned_blobs_to_identity: ", number_of_assigned_blobs_to_identity)
        print("number_of_errors_in_assigned_blobs: ", number_of_errors_in_assigned_blobs)
        print("individual_accuracy_assigned: ", individual_accuracy_assigned)
        print("accuracy_assigned: ", accuracy_assigned)
        print("\n")
        print("frames with identity errors: ", frames_with_identity_errors)
        print("fragments identifiers with identity errors: ", fragment_identifiers_with_identity_errors)
        print("\n")
        print("number_of_crossing_blobs: ", number_of_crossing_blobs)
        print("number_of_crossings_blobs_assigned_as_individuals: ", number_of_crossings_blobs_assigned_as_individuals)
        print("crossing_detector_accuracy: ", crossing_detector_accuracy)
        print("\n")
        print("frames with crossing errors: ", frames_with_crossing_errors)
        print("fragments identifiers with crossing errors: ", fragment_identifiers_with_crossing_errors)

        return accuracy, individual_accuracy, accuracy_assigned, individual_accuracy_assigned, frames_with_zeros_in_groundtruth

    else:
        print("there are fish with 0 identity in frame ", frames_with_zeros_in_groundtruth)
        return None, None, None, None, frames_with_zeros_in_groundtruth

def compute_and_save_session_accuracy_wrt_groundtruth(video, video_object_path):
    video.check_paths_consistency_with_video_path(video_object_path)
    # change this
    print("loading list_of_blobs")
    list_of_blobs = ListOfBlobs.load(video.blobs_path)

    ''' select ground truth file '''
    print("loading groundtruth")
    groundtruth_path = os.path.join(video.video_folder,'_groundtruth.npy')
    groundtruth = np.load(groundtruth_path).item()
    blobs_in_video_groundtruth = groundtruth.blobs_in_video[groundtruth.start:groundtruth.end]
    blobs_in_video = list_of_blobs.blobs_in_video[groundtruth.start:groundtruth.end]

    print("computting groundtrugh")
    accuracy, \
    individual_accuracy, \
    accuracy_assigned, \
    individual_accuracy_assigned, \
    frames_with_zeros_in_groundtruth = get_accuracy_wrt_groundtruth(video, blobs_in_video_groundtruth, blobs_in_video)

    if accuracy is not None:
        print("saving accuracies in video")
        video.gt_start_end = (groundtruth.start,groundtruth.end)
        video.gt_accuracy = accuracy
        video.gt_individual_accuracy = individual_accuracy
        video.gt_accuracy_assigned = accuracy_assigned
        video.gt_individual_accuracy_assigned = individual_accuracy_assigned
        video.save()

if __name__ == '__main__':

    ''' select blobs_in_video list tracked to compare against ground truth '''
    session_path = selectDir('./') #select path to video
    video_object_path = os.path.join(session_path,'video_object.npy')
    print("loading video object...")
    video = np.load(video_object_path).item(0)

    compute_and_save_session_accuracy_wrt_groundtruth(video, video_object_path)
